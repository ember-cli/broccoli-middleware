'use strict';

var expect = require('chai').expect;
var RSVP = require('rsvp');
var broccoliMiddleware = require('./../lib/middleware');
var fixture = require('./helpers/fixture-path');
var TestHTTPServer = require('./helpers/test-http-server');

describe('broccoli-middleware', function() {
  describe('watcher resolves correctly', function() {
    var watcher;
    var server;

    beforeEach(function() {
      watcher = RSVP.Promise.resolve();

      watcher['builder'] = {};
    });

    afterEach(function() {
      server.stop();
      server = null;
    })

    it('responds with the given file if file is on disk', function() {
      watcher['builder']['outputPath'] = fixture('basic-file');
      var middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then(function(info) {
          return server.request('/index.html', {
            info: info
          });
        })
        .then(function(content) {
          expect(content).to.match(/This is broccoli middleware page/);
        });
    });

    it('responds with error if file not found', function(done) {

      watcher['builder']['outputPath'] = fixture('basic-file');
      var middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      var wrapperMiddleware = function(req, resp /*next*/) {
        middleware(req, resp, function(err) {
          var isRequestFinished = resp.finished;
          expect(isRequestFinished).to.be.false;
          expect(err.message).to.have.string('ENOENT');
          done();
        })
      };

      server = new TestHTTPServer(wrapperMiddleware);
      server.start()
        .then(function(info) {
          return server.request('/non-existent-file', {
            info: info
          });
        });
    });

    it('bypasses broccoli-middleware if request is a directory and autoIndex is set to false', function(done) {
      watcher['builder']['outputPath'] = fixture('no-index');
      var middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      var wrapperMiddleware = function(req, resp /*next*/) {
        middleware(req, resp, function() {
          var isRequestFinished = resp.finished;
          expect(isRequestFinished).to.be.false;
          done();
        })
      };
      server = new TestHTTPServer(wrapperMiddleware);

      server.start()
        .then(function(info) {
          return server.request('', {
            info: info
          });
        });
    });

    it('responds with directory structure template if request is a directory and autoIndex is set to true', function() {
      watcher['builder']['outputPath'] = fixture('no-index');
      var middleware = broccoliMiddleware(watcher, {
        autoIndex: true
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then(function(info) {
          return server.request('', {
            info: info
          });
        })
        .then(function(content) {
          expect(content).to.match(/Generated by Broccoli/);
        });
    });

    it('responds with index.html if request is a directory and autoIndex is set to false', function() {
      watcher['builder']['outputPath'] = fixture('basic-file');
      var middleware = broccoliMiddleware(watcher, {
        autoIndex: true
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then(function(info) {
          return server.request('', {
            info: info
          });
        })
        .then(function(content) {
          expect(content).to.match(/This is broccoli middleware page/);
        });
    });

    it('responds to streaming media requests when Range headers are requested', function (done) {

      watcher['builder']['outputPath'] = fixture('basic-file');
      var middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      server = new TestHTTPServer(middleware);
      server.start()
        .then(function(info) {
          return server.request('/index.html', {
            headers: { 'Range': 'bytes=0-6'},
            info: info
          });
        })
        .then(function (content) {
          expect(content).to.match(/<html>/);
          done();
        })
    });

    it('appropriately delivers byte slices corresponding to header Range values', function (done) {

      watcher['builder']['outputPath'] = fixture('basic-file');
      var middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      server = new TestHTTPServer(middleware);
      server.start()
        .then(function(info) {
          return server.request('/index.html', {
            headers: { 'Range': 'bytes=100-108'},
            info: info
          });
        })
        .then(function (content) {
          expect(content).to.match(/broccoli/);
          done();
        })
    });
  });

  describe('watcher is rejected', function() {
    var watcher;
    var server;

    beforeEach(function() {
      watcher = RSVP.Promise.reject({
        stack: 'Build error',
        broccoliPayload: 'Broccoli files messed up'
      });

      watcher['builder'] = {};
    });

    afterEach(function() {
      server.stop();
      server = null;
    })

    it('returns HTTP 500 when there is build error', function() {
      watcher['builder']['outputPath'] = fixture('basic-file');
      var middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then(function(info) {
          return server.request('/index.html', {
            info: info
          });
        })
        .catch(function(error) {
          expect(error).to.match(/StatusCodeError: 500/);
        });
    });
  });
});
